<!DOCTYPE html>
<html>
<head>
<title>Časovna in prostorska zahtevnost</title>
<meta charset="utf-8">
<link rel="stylesheet" href="../../pomozno/prosojnice.css" />
</head>
<body>
<textarea id="source">

class: center, middle

# Programiranje 1

## Časovna in prostorska zahtevnost

### 23. november 2017

---

### Spomnimo se ideje **notacije velikega O**

## .center[$$f \in O(g)$$]

### .center[če za dovolj velike \\\\(x\\\\) velja]

## .center[$$f(n \cdot x) \lessapprox g(n) \cdot f(x)$$]

---

### Pravilna definicija **notacije velikega O**

## .center[$$f \in O(g)$$]

## $$\exists M, x_0. \forall x > x_0. |f(x)| \leq M \cdot |g(x)|$$

---

### Kaj je pomen definicije?

### $$\exists \color{purple}{M}, \color{red}{x_0}. \forall x > \color{red}{x_0}. |f(x)| \leq \color{purple}{M} \cdot |\color{blue}{g}(x)|$$

### .center[![](O-graf.png)]

--

### Rast funkcije \\(f\\) je omejena s funkcijo \\(g\\)

---

### Lastnosti notacije velikega O

### $$f \in O(g), a \in \mathbb{R} \implies a \cdot f \in O(g)$$

### $$f_1 \in O(g_1), f_2 \in O(g_2) \implies f_1 + f_2 \in O(|g_1| + |g_2|)$$

### $$f_1 \in O(g_1), f_2 \in O(g_2) \implies f_1 \cdot f_2 \in O(g_1 \cdot g_2)$$

---

### Pri zapisu smo dostikrat površni

### $$n \mapsto n^2 + 3 n \in O(n \mapsto n^2)$$
### $$n^2 + 3 n \in O(n^2)$$
### $$n^2 + 3 n = O(n^2)$$

### Površni smo tudi pri lastnostih

### $$a \cdot O(g) = O(g)$$
### $$O(g_1) + O(g_2) = O(g_1 + g_2)$$
### $$O(g_1) \cdot O(g_2) = O(g_1 \cdot g_2)$$

---

class: question, center

## Katere trditve so veljavne?

|                     |
| :-----------------: | :-:
| \\( 3 n^2 - 1000 n \in O(n^2) \\)  | .green.spoiler[**DA**]
| \\( 1000 n^2 + 0.0001 n^3 \in O(n^2) \\)  | .red.spoiler[**NE**]
| \\( 1000 n^2 + 0.0001 n^3 \in O(n^3) \\)  | .green.spoiler[**DA**]
| \\( 1000 n^2 + 0.0001 n^3 \in O(n^4) \\)  | .green.spoiler[**DA**]
| \\( n^{1000} + 2^n \in O(n^{1000}) \\)  | .red.spoiler[**NE**]
| \\( n^{1000} + 2^n \in O(2^n) \\)  | .green.spoiler[**DA**]

---

class: center

## časovna zahtevnost

### največ koliko časa potrebuje<br>algoritem glede na velikost vhodnih podatkov

.left[
* Ali seznam dolžine \\(n\\) vsebuje število 0: .spoiler[\\\\(O(n)\\\\)]
* Vsota dveh matrik velikosti \\(n \times n\\): .spoiler[\\\\(O(n^2)\\\\)]
* Produkt dveh matrik velikosti \\(n \times n\\): .spoiler[\\\\(O(n^3)\\\\)]
* Sled matrike velikosti \\(n \times n\\): .spoiler[\\\\(O(n)\\\\)]
]

---

class: center

## prostorska zahtevnost

### največ koliko dodatnega prostora potrebuje algoritem glede na velikost vhodnih podatkov


.left[
* Ali seznam dolžine \\(n\\) vsebuje število 0: .spoiler[\\\\(O(1)\\\\)]
* Vsota dveh matrik velikosti \\(n \times n\\): .spoiler[\\\\(O(n^2)\\\\)]
* Produkt dveh matrik velikosti \\(n \times n\\): .spoiler[\\\\(O(n^2)\\\\)]
* Sled matrike velikosti \\(n \times n\\): .spoiler[\\\\(O(1)\\\\)]
]

---

class: center, middle, question

# Ali med prostorsko in časovno zahtevnostjo obstaja povezava?

---

### Pythonovi seznami so implementirani s tabelami

.left-column[.terminal[```python
x = 10
s = [6, 2, 4]
```]]

.right-column[.right[![](seznam-python.png)]]

--

```python
 0   0   0   0   0   0      x : 8
 0 123  10   0   0   0      s : 19
 0   0   0   0   0   0
246  3   6   2   4   0
 0   0   0   0   0   0
```

Na mestih `123` in `246` je shranjena še definicija
razredov `int` in `list`.

---

### OCamlovi seznami so implementirani z verižnimi seznami

.left-column[.terminal[```ocaml
let x = 10
let s = [6; 2; 4]
```]]

.right-column[.right[![](seznam-ocaml.png)]]

--

```ocaml
 0   0   0   0   0   0      x : 8
 0  10   0   0   0   0      s : 19
 0   0   1   2  22   0
 1   6  15   1   4  30
 0   0   0   0   0   0
```

Pomen konstruktorjev `[]` in `::` je določen že ob prevajanju.

---

### Primerjava seznamov v Pythonu in OCamlu

| tip                                | predstavitev         | spremenljivost
| ------------------------------: |:-------------: | :--------------:
| Python `list`                   | tabele | spremenljivi
| OCaml `list`                    | verižni seznami | nespremenljivi
| OCaml `array`                    | tabele | spremenljivi
| če v Pythonu napišemo svoj razred `MojSeznam`        | verižni seznami | spremenljivi

---

class: question

## Kakšna je časovna zahtevnost sledečih operacij?

|                                 | Python         | OCaml
| ------------------------------: |:-------------: | :--------------:
| indeksiranje                    | .spoiler[O(1)] | .spoiler[O(n)]
| dodajanje na začetek            | .spoiler[O(n)] | .spoiler[O(1)]
| dodajanje na konec              | .spoiler[O(1)] | .spoiler[O(n)]
| izračun dolžine seznama         | .spoiler[O(1)] | .spoiler[O(n)]
| izračun repa seznama            | .spoiler[O(n)] | .spoiler[O(1)]
| ugotavljanje prisotnosti        | .spoiler[O(n)] | .spoiler[O(n)]

---

class: question

## Kakšna je prostorska zahtevnost sledečih operacij?

|                                 | Python         | OCaml
| ------------------------------: |:-------------: | :--------------:
| indeksiranje                    | .spoiler[O(1)] | .spoiler[O(1)]
| dodajanje na začetek            | .spoiler[O(n)] | .spoiler[O(1)]
| dodajanje na konec              | .spoiler[O(1)] | .spoiler[O(n)]
| izračun dolžine seznama         | .spoiler[O(1)] | .spoiler[O(1)]
| izračun repa seznama            | .spoiler[O(n)] | .spoiler[O(1)]
| ugotavljanje prisotnosti        | .spoiler[O(1)] | .spoiler[O(1)]

---

### Izračunajmo število različnih elementov seznama

.source[```
let stevilo_razlicnih xs =
  let rec aux ze_videni = function
    | [] -> List.length ze_videni
    | x :: xs when List.mem x ze_videni ->
        aux ze_videni xs
    | x :: xs -> aux (x :: ze_videni) xs
  in
  aux [] xs
```]

--

### V resnici ni treba, da videne elemente shranjujemo v seznam

---

### Želimo si učinkovito predstavitev množic

.bad-example[```
let velikost m = List.length m
let vsebuje x m = List.mem x m
let dodaj x m = x :: m
```]

.source[```
let stevilo_razlicnih xs =
  let rec aux ze_videni = function
    | [] -> velikost ze_videni
    | x :: xs when vsebuje x ze_videni ->
        aux ze_videni xs
    | x :: xs -> aux (dodaj x ze_videni) xs
  in
  aux [] xs
```]

---

### Radi bi **učinkovito** predstavili množice

|                                 | iskanje        | dodajanje
| ------------------------------: |:-------------: | :--------------:
| tabela                          | .spoiler[O(n)] | .spoiler[O(1)]
| verižni seznam                  | .spoiler[O(n)] | .spoiler[O(1)]
| urejena tabela                  | .spoiler[O(log n)] | .spoiler[O(n)]
| urejen verižni seznam           | .spoiler[O(n)] | .spoiler[O(n)]
| .spoiler[zgoščevalne tabele?!]    | .spoiler[O(1)] | .spoiler[O(1)]
| .spoiler[iskalna drevesa]       | .spoiler[O(log n)] | .spoiler[O(log n)]

---

class: center, middle

# Programiranje 1

## Iskalna drevesa

### 23. november 2017

---

.center[![](iskalno-drevo.png)]

### Dvojiško drevo je iskalno, če:

* so vsi elementi levega otroka manjši od korena
* so vsi elementi desnega otroka večji od korena
* sta levi in desni otrok tudi iskalni drevesi

---

### Elemente iščemo rekurzivno

.center[![](iskalno-drevo-najdi.png)]

### Število 15 je v drevesu

---

### Elemente iščemo rekurzivno

.center[![](iskalno-drevo-ne-najdi.png)]

### Števila 41 ni v drevesu

---

### Elemente rekurzivno vstavimo na mesto, kjer bi jih sicer našli

.center[![](iskalno-drevo-vstavi.png)]

---

### Elemente v listih odstranimo enostavno

.center[![](iskalno-drevo-brisi-list.png)]


---

### Korena zaradi otrok ne moremo odstraniti

.center[![](iskalno-drevo-brisi-koren.png)]

---

### Koren lahko odstranimo,<br>če ga nadomestimo s predhodnikom

.center[![](iskalno-drevo-zamenjaj-koren-s-predhodnikom.png)]

---

### Koren lahko odstranimo,<br>če ga nadomestimo z naslednikom

.center[![](iskalno-drevo-zamenjaj-koren-z-naslednikom.png)]

---

class: center, middle, question

# implementacija <br>iskalnih dreves v OCamlu

---

class: center, middle, question

# implementacija <br>iskalnih dreves v Pythonu


</textarea>
<script src="../../pomozno/prosojnice.js"></script>
</body>
</html>
